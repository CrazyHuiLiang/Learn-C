# 函数与程序结构

C语言程序一般都由许多小的函数组成，一个程序可以保存在一个或者多个源文件中。各个文件可以单独编译，并可以与库中已编译过的函数一起加载。

如果函数定义中省略了返回值类型，则默认认为int类型。

程序可以看成变量定义和函数定义的集合。函数之间的通信可以通过参数、函数返回值以及外部变量。

假定由三个函数分别存在名为main.c、getline.c、strindex.c的三个文件中，则可以使用命令：

```bash
cc main.c getline.c strindex.c
```

来编译这3个文件，并把生成的目标文件分别存放在main.o、getline.o、strindex.o中，然后再把这3个文件一起加载到可执行文件a.out中。

如果源文件中存在错误（比如main.c中存在错误），则可以通过命令：

```bash
cc main.c getline.o strindex.o
```

对main.c文件重新编译，并将编译结果与以前已编译过的目标文件getline.o,strindex.o一起加载到可执行文件中。

- 如果函数有参数，则要声明他们
- 如果没有参数，则使用void进行声明

## 外部变量

C语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或者函数。形容词external与internal是相对的，internal用于描述定义在函数内部的函数参数及变量。
外部变量定义在函数之外，因此可以在许多函数中使用。由于C语言不允许在一个函数中定义其他函数，因此函数本身是“外部的”。

外部变量的用途还表现在他们与内部变量相比具有更大的作用域和更长的生存期。自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时，变量也将消失。
而外部变量是永久存在的，他们的值在一次函数调用到下一次函数调用之间保持不变。

## 作用域规则

构成C语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载。

名字的作用域指的是程序中可以使用该名字的部分。

外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾。

如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字extern。

将外部变量的`声明`与`定义`严格区分开很重要：

- 变量声明用来说明变量的属性（主要是变量的类型）
- 变量的定义除此之外还将引起存储器的分配

在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它。外部变量的定义中必须指定数组的长度，但extern声明则不一定要指定数组的长度。

## 头文件

我们考虑将程序分割到若干源文件中的情况，考虑定义和声明在文件之间的共享问题，我们尽可能把共享的部分集中在一起，这样就需要一个副本，改进程序时也容易保证程序的正确性。

头文件使用扩展名 `.h` ，在需要使用该头文件时通过#include指令将他们包含进来。

对于中等规模的程序，最好用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件，我们需要精心地组织他们。

## 静态变量

用static声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。通过static限定外部变量，可以达到隐藏外部对象的目的。外部的static声明通常多用于变量，当然也可以声明函数。

static也可以用于声明内部变量。static类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用。但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。

## 寄存器变量

register声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将register变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。

register声明只适用于自动变量以及函数的形式参数。

无论寄存器变量实际是不是存放在寄存器中，它的地址都是不能访问的。

## 程序块结构

C语言不允许在函数中定义函数。

每次进入程序块时

- 在程序块内声明以及初始化的自动变量都将被初始化。
- 静态变量只在第一次进入程序块时被初始化一次。

自动变量（包括形式参数）可以隐藏同名的外部变量和函数。在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。

## 初始化

在不进行显式初始化的情况下

- 外部变量和静态变量都将被初始化为0
- 自动变量和寄存器变量的初始值则没有定义（即初值为无用的信息）

数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔，比如：

```c
int days[] = {31, 28, 31, 30, 31, 30, 31,31, 30, 31, 30, 31};
```

如果初始化表达式的个数比数组元素数少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将会被初始化为0；
如果初始化表达式的个数比数组元素多，则时错误的。
不能一次将一个初始化表达指定给多个数组元素，也不能跳过前面的数组元素而直接初始化后面的数组元素。

字符数组的初始化比较特殊：可以用一个字符串代替用花括号括起来并用逗号分隔的初始化表达式序列。

## C预处理器

C语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：

- #include指令，用于在编译期间把指定文件的内容包含进当前文件中
- #define指令，用任意字符序列替换一个标记

### 文件包含

形如:

```c
#include "文件名"
#include <文件名>
```

的行都将被替换为文件名指定的文件内容。如果文件名用引号引起来，则在源文件所在位置查找该文件；如果没有在该位置找到文件，或者如果文件名是用尖括号括起来的，则将根据相应规则查找该文件，这个规则同具体实现有关。

### 宏替换

```c
#define 名字 替换文本
```

最简单的宏替换 - 后续所有出现名字记号的地方都被替换为替换文本。可以把一个较长的宏定义分成若干行，这时需要在待续行尾加上一个反斜杠。
`#define` 定义的名字的作用域从其定义点开始，到被编译的源文件的末尾处结束。
宏定义也可以用前面出现的宏定义。
替换只对记号进行，对括在引号中的字符串不起作用。

宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。例如：

```c
#define max(A, B) ((A)>(B)?(A):(B))
```

宏定义存在一些缺陷，其中，作为参数的表达式要重复计算两次，如果表达式存在副作用（比如含有自增运算或输入/输出），则会出现不正确的情况。例如：

```c
max(i++, j++);
```

同时还必须注意，要适当使用圆括号以保证计算次序的正确性。

可以通过`#undef`指令取消名字的宏定义

#### 参数名以#作为前缀

形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。例如，可以将它与字符串连接运算结合起来编写一个调试打印宏：

```c
#define dprint(expr) printf(#expr " = %g\n", expr)

// 使用语句
dprint(x/y);
// 会被扩展为
printf("x/y" " = %g\n", x/y);
```

#### 运算符##

预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与##相邻，则该参数将被实际参数替换，##与前后的空白符将被删除，并对替换后的结果重新扫描。例如：

```c
#define paste(front, back) front ## back

paste(name, 1)
// 结果将建立记号name1
```

#### 条件包含

还可以使用条件语句对预处理本身进行控制，这种条件语句的值在预处理执行的过程中进行计算。这种方式为在编译过程中根据计算所得的条件选择性地包含不通代码提供了一种手段。

`#if`语句对其中的常量整型表达式（其中不能包含sizeof、类型转换或enum常量）进行求职，若表达式的值不等于0，则包含其后的各行，直到遇到`#endif`、`#elif`、`#else`语句为止。

在`#if`语句中可以使用表达`defined(名字)`，该表达式的值遵循下列规则：当名字已经定义时，其值为1，否则为0

```c
#if !defined(HDR)
#define HDR
#endif
```

```c
#if SYSTEM == SYSV
    #define HDR 'sysv.h'
#elif SYSTEM ==BSD
    #define HDR 'bsd.h'
#else
    #define HDR 'default.h'
#endif
#include HDR
```

C语言专门定义了两个预处理语句`#ifdef`与`#ifndef`,用来测试某个名字是否已定义

```c
#ifndef HDR
#define HDR
/* hdr.h文件的内容放在这里 */
#endif
```
