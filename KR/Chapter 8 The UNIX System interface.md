# UNIX 系统接口

UNIX 操作系统通过一系列的系统调用提供服务，这些系统调用实际上是操作系统内的函数，他们可以被用户程序调用。
ANSI C 标准函数库是以 UNIX 系统为基础建立起来的。

## 8.1 文件描述符

所有的外围设备都被看作是文件系统的文件，因此，所有的输入/输出都要通过读文件或写文件完成。也就是说，通过一个
单一的接口就可以处理外围设备和程序之间的所有通信。

通常情况下，在读或写文件之前，必须先将这个意图通知系统，该过程称为打开文件。
如果是写一个文件，则可能需要先创建该文件，也可能需要丢弃该文件中原先已存在的内容。
系统检查你的权利，如果一切正常，操作系统将向程序返回一个小的非负整数，该整数称为文件描述符。
任何时候对文件的输入/输出都是通过文件描述符标识文件，而不是通过文件名标识文件。
系统负责维护已打开文件的所有信息，用户程序只能通过文件描述符引用文件。

当命令解释程序（shell）运行一个程序的时候，它将打开3个文件，对应的文件描述符分别是0、1、2，依次表示标准输入、标准输出、和标准错误。如果程序从文件0中读，对1和2进行写，就可以进行输入/输出而不必关心打开文件的问题。

程序的使用者可通过 `<` 和 `>` 重定向程序的 I/O：

```sh
prog < 输入文件名 >输出文件名
```

这种情况下，shell 把文件描述符 0 和 1 的默认赋值改变为指定的文件。
通常，文件描述符 2 仍与显示器相关联，这样，出错信息会输出到显示器上。可以通过下面表述将文件描述符2重定向至1：

```sh
prog > 输出文件 2>&1
```

`&` 用于指代文件描述符，而不是文件名。具体语法解释：

- 首先，`prog > 输出文件`：将 prog 的标准输出（文件描述符1）重定向到`输出文件`
- 然后，`2>&1` 中的 2 表示标准错误，`>&1` 表示将标准错误重定向到标准输出所指向的地方,这时标准输出已经被重定向到 `输出文件`,所以标准错误也会被重定向到同一文件。

## 8.2 低级I/O - read 和 write

输入与输出是通过 read 和 write **系统调用** 实现的，这两个函数中，第一个参数是文件描述符，第二个参数是程序中存放读或写的数据的字符数组，第三个参数是要传输的字节数。

```c
int n_read = read(int fd, char *buf, int n);
int n_written = write(int fd, char *buf, int n);
```

每个调用返回实际传输的字节数。
在读文件时，函数的返回值可能会小于请求的字节数。如果返回0，则代表已到达文件的结尾；如果返回-1，则代表发生了某种错误。
在写文件时，返回值是实际写入的字节数。如果返回值与请求写入的字节数不相等，则说明发生了错误。

在一次调用中，读出或写入的数据的字节数可以为任意大小。最常用的值为1，即每次读出或写入1个字符（无缓冲），
或是类似于1024或4096这样的与外围设备的物理块大小相应的值。

用更大的值调用该函数可以获得更高的效率，因为系统调用的次数减少了。

## open、creat、close 和 unlink

处理默认的标准输入、标准输出和标准错误的文件之外，其他的文件都必须在读或写之前显示地打开。早先，系统用 open 和 creat 用于实现该功能。在现代编程中，creat 几乎已经被淘汰，而 open 函数提供了更强大的功能和灵活性。

早先，open 与 fopen 很相似，不同之处是，它仅仅返回一个 int 类型的数值代表文件描述符，如果发生错误，open 将返回 -1。

```c
int open(char *name, int flags, int perms)
int creat(char *name, int perms)
```

参数 name 是一个包含文件名的字符串。open 的第二个参数 flags 是一个 int 类型的值，它说明以何种方式打开文件，主要的几个值如下：

- O_RDONLY
- O_WRONLY
- ORDWR

在 System V UNIX 系统中，这些常量在头文件 `<fcntl.h>` 中定义，而在 BSD 版本中则在 `<sys/file.h>` 中定义。

当文件不存在时，可以使用 creat 系统调用创建新文件或覆盖已有的旧文件。如果成功创建了文件，它将返回一个文件描述符，否则返回 -1.
如果此文件已存在，creat 将把该文件的长度截断为 0，从而丢弃原先已有的内容。使用 creat 创建一个已存在的文件不会导致错误。

如果创建的文件不存在，则 creat 用参数 perms 指定的权限创建文件。

在 UNIX 文件系统中，每个文件对应一个 9 比特的权限信息，它们分别控制文件的所有者、所有者组和其他成员对文件的读、写和执行访问权限。因此通过一个 3 位的八进制数就可以方便的说明不同的权限。(文件权限一般用一个四位的八进制数来表示，每一个八进制数对应三个二进制位，因此四个八进制数总共表示 12 个比特的信息。例如：0755，其中的0所在位置代表特殊权限位（Setuid, Setgid，Sticky bit），755所在位置分别用户权限、组权限和其他成员权限)

标准库函数 vprintf 函数与 printf 函数类似，所不同的是，它用一个参数取代了变长参数表，且此参数通过调用 va_start 宏进行初始化。

一个程序同时打开的文件数是有限制的（通常是20）。函数 close(int fd) 用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其他文件使用。

函数 unlink(char *name) 将文件 name 从文件系统中删除，它对应于标准库函数 remove。

## 8.4 随机访问 - lseek

输入/输出通常是顺序进行的：每次调用 read 和 write 进行读写的位置紧跟在前一次操作的位置之后。

```c
long lseek(int fd, long offset, int origin)
```

系统调用 lseek 可以在文件中任意移动位置而不实际读写任何数据。将文件描述符为 fd 的文件的当前位置设置为 offset，其中，offset 是相对 origin 指定的位置而言的。随后进行的读写操作将从此位置开始。

origin 的值可以为 0、1 或 2，分别用于指定 offset 从文件开始、从当前位置或从文件结束处开始算起。

lseek 系统调用返回一个 long 类型的值，此值表示文件的新位置，若发生错误，则返回 -1。
标准库函数 fseek 与系统调用 lseek 类似，不同的是，前者第一个参数是 `FILE *` 类型，且发生错误时返回一个非 0 值。

