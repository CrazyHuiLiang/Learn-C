# 指针与数组

指针是一种保存变量地址的变量。

ANSI C使用类型`void *`代替`char *`作为通用指针类型。

## 指针与地址

一元运算符 `&` 可以取一个对象的地址，地址运算符&只能应用于内存中的对象，即变量与数组元素。他不能作用于表达式、常量或register类型的变量。

一元运算符`*`是间接寻址或间接引用运算符。将它作用于指针时，将访问指针所指向的对象。

每个指针都必须指向某种特定的数据类型。一个例外情况是指向`void *`类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。

## 指针 与 数组

通过数组下标能完成的任何操作都可以通过指针来实现。一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。

```c
int a[10];
int *pa;
pa = &a[0];
```

如果pa指向数组的某个特定元素，那么，根据指针运算定义，pa+1将指向下一个元素。

数组类型的变量或表达式的值是该数组第0个元素的地址。

```c
pa = &a[0];
// 等价
pa = a;

// 对数组元素 a[i] 的引用也可以写成
*(a + i)
```

我们必须记住，数组名和指针之间有一个不同之处。指针是一个变量，因此，在C语言中，语句pa=a和pa++都是合法的。但数组名不是变量，因此a=pa和a++形式的语句是非法的。

当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。数组名参数必须是一个指针，也就是一个存储地址值的变量。在函数定义中，下面两种形式参数是等价的：

```c
char s[];
char *s;
```

## 地址算术运算

将指针、数组和地址的算术运算集成在一起是C语言的一大优点。同其他类型的变量一样，指针也可以初始化。通常对指针有意义的初始化值只能是0或者表示地址的表达式，对后者来说，表达式所代表的地址必须是此前已定义的具有适当类型的数据和地址。例如：

```c
// 将allocp定义为字符类型指针
char *allocp = allocbuf;
```

C语言保证，0永远不是有效的数据地址，因此，返回值0可用来表示发生了异常事件。

指针与整数之间不能相互转换，但0是唯一的例外：常量0可以赋值给指针，指针也可以和常量0进行比较。程序中经常用符号常量NULL代替常量0，这样便于更清晰地说明常量0是指针的一个特殊值。符号常量NULL定义在标准头文件`<stddef.h>`中。

如果指针p和q指向同一个数组的成员，那么他们之间就可以进行类似于==、!=、<、>=的关系比较运算。指向位置靠后的指针为大。

任何指针与0进行相等或不等的比较都有意义。但是指向不同数组的元素的指针之间的算术或比较运算没有定义。指针的算术运算中可以使用数组最后一个元素的下一个元素的地址。

`p+n`表示指针p当前指向的对象之后第n个对象地址。无论指针p指向的对象是何种类型都成立。在计算`p+n`时，n将根据p指向的对象的长度按比例缩放，而p指向的对象的长度则取决于p的声明。

有效的指针运算包括：

- 相同类型指针之间的赋值运算；
- 指针同整数之间的加法或减法运算；
- 指向相同数组中元素的两个指针间的减法或比较运算；
- 将指针赋值为0或指针与0之间的比较运算

## 字符指针与函数

字符串常量是一个字符数组

```c
"I am a string"
```

在字符串的内部表示中，字符数组以空字符`\0`结尾，所以，程序可以通过检查空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大1.

## 指针数组以及指向指针的指针

由于指针本身也是变量，所以他们也可以像其他变量一样存储在数组中。

```c
char *lineptr[MAXLINES]
```

它表示lineptr是一个具有MAXLINES个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。

## 多维数组

C语言提供了类似矩阵的多维数组。

```c
static char daytab[2][13] = {
    {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
};
```

二维数组实际上是一种特殊的一维数组，它的每个元素也是一个一维数组。因此，数组下标应该写成

```c
daytab[i][j] // [行][列]
```

如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。
数组的行数没有太大关系，函数调用时传递的是一个指针，它指向由行向量构成的一维数组。

```c
// 如果将daytab作为参数传递给函数f，那么f的声明应该写成下列形式
f(int daytab[2][13]) {}
// 应为行数无关紧要
f(int daytab[][13]) {}
// 声明方式的参数是一个指针，它指向具有13个整型元素的一维数组。因为方括号[]的优先级高于*，所以声明必须用圆括号。
f(int (*daytab)[13]) {}
```

一般来说，除数组的第一维下标可以不指定大小外，其余各维都必须明确指定大小。

## 指针数组的初始化

```c
char *name[] = {"January", "February"};
```

没有指明数组name的长度，编译器编译时将对初值个数进行统计，并将这一准确数字填入数组长度。

## 指针与多维数组

假如有下面两个定义：

```c
int a[10][20];
int *b[10];
```

从语法角度讲，`a[3][4]`和`b[3][4]`都是对一个int对象的合法引用。但a是一个真正的二维数组，它分配了200个int类型长度的存储空间；
但是对b来说，该定义仅仅分配了10个指针，并且没有对他们初始化，他们的初始化必须以显式的方式进行。

假定b的每个元素都指向一个具有20个元素的数组，那么编译器就要为他分配200个int类型长度的存储空间以及10个指针的存储空间。
指针数组的一个重要优点在于，数组每一行长度可以不同。

## 命令行参数

在支持C语言环境中，可以在程序开始执行时将命令行参数传递给程序。调用主函数main时，它带有两个参数。第一个参数(习惯上称为argc，用于参数计数)的值表示运行程序时命令行中参数的数目；第二个参数（称为argv，用于参数向量）是一个指向字符数组的指针，其中每个字符串对应一个参数。按照C语言的约定，argv[0]的值是启动该程序的程序名，因此argc的值至少为1。另外，ANSI标准要求argv[argc]的值必须为一空指针。

UNIX系统中的C语言程序有一个公共的约定：以符号开头的参数表示一个可选标志或参数。例如用-x（代表“除...之外”）；可选参数应该允许以任意次序出现，同时，程序的其余部分应该与命令行中的参数数目无关。

## 指向函数的指针

函数本身不是变量，但可以定义指向函数的指针，这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等。

```c
int numcmp(char *s1, char *s2);
// 第四个参数表明comp是一个指向函数的指针，该函数具有两个void *类型的参数，其返回值类型为int。
void qsort(void *lineptr[], int left, int right, int (*comp)(void *, void *));
// 在调用函数qsort的语句中，numcmp是函数的地址。因为他们是函数，所以前面不需要加上取地址符&，同样的原因，数组名前面也不需要&运算
qsort((void **)lineptr, 0, nlines-1, (int (*comp)(void *, void *))numcmp);

void qsort(void *lineptr[], int left, int right, int (*comp)(void *, void *)) {
    ...
    // comp的使用和其声明是一致的，comp是一个指向函数的指针，*comp代表一个函数。
    if((*comp)(v[i], v[left]) < 0) {
        ...
    }
    ...
}
```

