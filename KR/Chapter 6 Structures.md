# 结构

结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。

结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。在 ANSI 标准中，自动结构和数组现在也可以进行初始化。

## 结构的基础知识

```c
struct point {
    int x;
    int y;
}
```

关键字 `struct` 引入结构声明。结构声明由花括号内的一系列声明组成。关键字 `struct` 后面的名字是可选的，称为结构标记（上面中的 point）。结构中定义的变量称为成员。

`struct` 声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的。

```c
struct {...} x, y, z;
```

如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模板和轮廓。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如，对于上面给出的结构声明 point

```c
// 定义了一个 struct point 类型的变量 pt
struct point pt;
```

结构的初始化可以在定义的后面使用初值表进行。初值表中同每个成员对应的初值必须是常量表达式，例如：

```c
struct point maxpt = {320, 200};
```

可以通过下列形式引用某个特定结构中的成员：

```c
结构名.成员
```

结构可以嵌套，例如：

```c
struct rect {
    struct point pt1;
    struct point pt2;
}

// 声明 screen 变量
struct rect screen;

// 引用 screen 的成员 pt1 的 x 坐标
screen.pt1.x
```

## 结构与函数

结构的合法操作只有几种：作为一个整体复制和赋值，通过 `&` 运算符取地址，访问其成员。

其中复制和赋值包括向函数传递参数以及从函数返回值。

结构之间不可以进行比较。

至少可以通过 3 中可能的方法传递结构：

- 分别传递各个结构成员
- 传递整个结构
- 传递指向结构的指针

结构类型的参数和其他类型参数一样，都是通过值传递的。如果传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率要高。结构指针类似于普通变量指针：

```c
// 定义 pp 为一个指向 struct point 类型对象的指针
struct point *pp;

*pp         // 为该结构
(*pp).x     // 是结构成员，圆括号是必需的，因为结构成员运算符 “.” 的优先级比 “*” 的优先级高
```

结构指针的使用频度非常高，为了使用方便，C语言提供了另一种简写方式。假定 p 是一个指向结构的指针，可以用

```c
// 这种形式应用相应的结构成员
p -> 结构成员

// 等价于
(*p).结构成员
```

## 结构数组

```c
// 声明一个结构类型 key，并定义了该类型的结构数组 keytab，同时为其分配存储空间
struct key {
    char *word;
    int count
} keytab[NKEYS];

// 可以等价的写成下列形式
struct key {
    char *word;
    int count;
};
struct key keytab[NKEYS];
```

这种结构的初始化方法同前面所述的初始化方法类似，在定义的后面通过一个花括号括起来的初始值表进行初始化，如：

```c
struct key {
    char *word;
    int count
} keytab[] = {
    "auto", 0,
    "break": 0,
    "case", 0
};

// 与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结构）的初值都括在花括号内
struct key {
    char *word;
    int count
} keytab[] = {
    {"auto", 0},
    {"break": 0},
    {"case", 0}
};
```

C语言提供了一个编译时(compile-time)一元运算符 `sizeof`，它可用来计算任一对象的长度，表达式：

```c
sizeof 对象
// 以及
sizeof (类型名)
```

将返回一个整型值（无符号整型值，其类型为 `size_t`，该类型在头文件 `<stddef.h>` 中定义），它等于指定对象或类型占用的存储空间字节数。

## 指向结构的指针

两个指针之间的加法运算是非法的。但是，指针的减法运算却是合法的， high - low 的值就是数组元素的个数。

C语言的定义保证数组末尾之后的第一个元素（即 &tab[n]）的指针算术运算可以正确执行。

不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要求，所以，结构中可能出现未命名的空穴（hole）。使用 sizeof 运算符可以返回正确的对象长度。

## 自引用结构

我们简单讨论一下有关存储分配程序的问题。尽管存储分配程序需要为不同的对象分配存储空间，单显然，程序中只会有一个存储分配程序。

但是，假定用一个分配程序来处理多种类型的请求，比如指向 `char` 类型的指针和指向 `struct tnode` 类型的指针，则会出现两个问题。

- 第一，它如何在大多数实际机器上满足各种类型对象的对齐要求（例如，整形通常必须分配在偶数地址上）
- 第二，使用什么样的声明能处理分配程序必须能返回不同类型的指针的问题

对齐要求一般比较容易满足，只需要确保分配程序始终返回满足所有对齐限制要求的指针就可以了，其代价是牺牲一些存储空间。

在严格类型检查的语言来说，像 `malloc` 这样的函数的类型声明总是很令人头疼的问题。在C语言中，一种合适的方法是将 `malloc` 的返回值声明为一个指向 `void` 类型的指针，然后再显示地将该指针强制转换为所需类型。

## 类型定义（typedef）

C语言提供了称为 `typedef` 的功能，它用来建立新的数据类型名，例如，声明

```c
// 将 Length 定义为与 int 具有同等意义的名字
typedef int Length;
```

举一个更复杂的例子：用 `typedef` 定义本章前面介绍的树节点。

```c
// 一个指向该结构的指针 Treeptr
typedef struct tnode *Treeptr;

// 一个结构 Treenode
typedef struct tnode {
    char *word;
    int count;
    Treeptr left;
    Treeptr right;
} Treenode;

// 使用这两个新类型关键字
Treeptr talloc(void) {
    return (Treeptr) malloc(sizeof(Treenode));
}
```

这里要强调的是，从任何意义上讲，`typedef` 声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已。

`typedef` 类似于 `#define` 语句，但由于 `typedef` 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。例如

```c
// 定义了类型 PFI 是“一个指向函数的指针”
typedef int (*PFI)(char *, char*);

// 它可以用在某些上下文中，例如，第 5 章的排序程序中
PFI strcmp, numcmp;
```

使用 `typedef` 还有另外两个重要原因。

- 首先，它可以使程序参数化，以提高程序的可移植性。如果 `typedef` 声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需要改变 `typedef` 类型定义就可以了
- 第二个作用是为程序提供更好的说明性。 Treeptr 声明显然比一个声明为指向复杂结构的指针更容易让人理解。

## 联合

联合是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。
联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要再程序中嵌入任何同机器有关的信息。

一个变量可以合法地保存多种数据类型中的任意一种类型的对象。其语法基于结构，如下所示：

```c
union u_tag {
    int ival;
    float fval;
    char *sval;
} u;
```

变量 u 必须足够大，以保存这 3 种类型中最大的一种，具体长度同具体的实现有关。

这些类型中的任何一种类型的对象都可以赋值给 u，且可以使用随后的表达式中，但必须保证是一致的：读取的类型必须是最近一次存入的类型。程序员负责跟踪当前保存在联合中的类型。**如果保存的类型与读取的类型不一致，其结果取决于具体的实现**。

可以通过下列语法访问联合中的成员：

```c
联合名.成员

// 或

联合指针->成员
```

它与访问结构的方式相同。

实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都是 0，此结构空间要大到足够容纳最宽的成员，并且，其对齐方式要适合联合中所有类型的成员。

对联合允许的操作与对结构允许的操作相同：作为一个整体单元进行赋值、复制、取地址及访问其中一个成员。

联合只能用其第一个成员类型的值进行初始化。

## 位字段

在存储空间很宝贵的情况下，有可能需要将多个对象保存在一个机器字中。

C语言提供了一种方法，直接定义和访问一个字中的位字段的能力，而不需要通过按位逻辑运算符。位字段（bit-field），或简称字段，是“字”中相邻位的集合。

```c
// 这里定义了一个变量 flags，它包含 3 个一位的字段。冒号后的数字表示字段的宽度（用二进制位数表示）。字段被声明为 unsigned int 类型，以保证它们是无符号量
struct {
    unsigned int is_keyword: 1;
    unsigned int is_extern : 1;
    unsigned int is_static : 1;
} flags;

// 单个字段的引用方式与其他结构成员相同，例如
flags.is_keyword = 1;
```

字段的作用与小整数相似。

字段的所有属性几乎都同具体的实现有关。字段能否覆盖字边界由具体的实现定义。字段可以不命名，无名字段（只有一个冒号和宽度）起填充作用。特殊宽度 0 可以用来强制在下一个字边界上对齐。

某些机器上字段的分配是从字的左端至右端进行的，而某些机器上相反。

字段也可以仅仅声明为 `int`，为了方便移植，需要显示声明该 `int` 类型为 `signed` 还是 `unsigned` 类型。

字段不是数组，并且没有地址，因此对他们不能使用 `&` 运算符。
